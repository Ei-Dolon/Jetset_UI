/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function f(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function y(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function r(e,...t){if(!f(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function g(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function p(e,t){r(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function w(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function x(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function b(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function d(e,t){return e<<32-t|e>>>t}const i=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function u(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function s(e){for(let t=0;t<e.length;t++)e[t]=u(e[t]);return e}const A=i?e=>e:s,c=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",a=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function E(e){if(r(e),c)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=a[e[n]];return t}function h(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function l(e){return typeof e=="string"&&(e=h(e)),r(e),e}class H{}function U(e){const t=o=>e().update(l(o)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}export{H,y as a,g as b,U as c,r as d,p as e,x as f,b as g,E as h,d as r,A as s,l as t,w as u};
